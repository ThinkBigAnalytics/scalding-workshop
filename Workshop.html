<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>Scalding Workshop</title>
<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax:{inlineMath:[['$$$','$$$']]}});</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<h1>Scalding Workshop</h1>

<p><strong>Dean Wampler, Typesafe</strong><br/>
<a href="mailto:dean@concurrentthought.com?subject=Question%20about%20your%20Scalding%20Workshop">dean@concurrentthought.com</a><br/>
<a href="https://twitter.com/deanwampler">@deanwampler</a><br/>
<a href="http://typesafe.com">Typesafe</a></p>

<p><img src="images/scalding-logo-small.png" alt="Scalding logo" /></p>

<p>This workshop/tutorial takes you through the basic principles of writing data analysis applications with <a href="https://github.com/twitter/scalding">Scalding</a>, a Scala API that wraps <a href="http://www.cascading.org/">Cascading</a>. Expect this workshop to take 3 hours or more, if you do all parts of the exercises. I certainly encourage you to experiment.</p>

<p>I assume you have already completed the setup instructions in the <a href="README.html">README</a>. These instructions walk you through a series of exercises. The exercises have a corresponding Scalding script (Scala source file). I used a convention of adding a number suffix to the name to indicate the order of the exercises. Note that some of these exercises are adapted from the Tutorial examples that are part of the Scalding Github repo, where noted.</p>

<p>This document will explain many features of the Scalding and Cascading. The scripts themselves contain additional details. The Scalding and Cascading documentation has more information than we can cover here:</p>

<ul>
<li><a href="http://www.cascading.org/documentation/">Cascading Documentation</a>, especially the <a href="http://www.cascading.org/documentation/">Cascading User Guide</a> and the <a href="http://docs.cascading.org/cascading/2.0/javadoc/">Javadocs</a>.</li>
<li><a href="https://github.com/twitter/scalding/wiki">Scalding Wiki</a>.</li>
<li>Scalding Scaladocs are not online, but they can be built from the <a href="https://github.com/twitter/scalding">Scalding Repo</a>. For convenience, I have included these files in the workshop as <code>api.zip</code>. Unzip the file and open the <a href="api/index.html">index</a>.</li>
<li><a href="http://blog.echen.me/2012/02/09/movie-recommendations-and-more-via-mapreduce-and-scalding/">Movie Recommendations</a> is a fantastic blog post with detailed, non-trivial examples using Scalding.</li>
<li><a href="https://github.com/snowplow/scalding-example-project">Scalding Example Project</a> is a full example designed to run on Hadoop, specifically on Amazon's EMR (Elastic MapReduce) platform.</li>
</ul>


<h2>Help a Brother Out!</h2>

<p>Feedback, patches, suggested additions are welcome! <a href="https://github.com/deanwampler/scalding-workshop">Fork me</a>.</p>

<h1>Basic Cascading Concepts</h1>

<p>Let's start with a very brief synopsis of key Cascading concepts useful for understanding Scalding. Not all Cascading features are wrapped with Scalding APIs. In some cases, equivalent Scala idioms are used, even though the implementations may delegate to Cascading equivalents.</p>

<p>See the Cascading User Guide for more details.</p>

<h2>Tuple</h2>

<p>A common data structure in many programming languages, a tuple is a grouping of a fixed number of fields, where each element has a specific type, the types of the different fields can be different and the fields can have names. It is analogous to a SQL record, a <code>struct</code> in C, and an object in object-oriented languages.</p>

<h2>Tap</h2>

<p>A <strong>Tap</strong> is a data <em>source</em> (for reading) or <em>sink</em> (for writing), corresponding to a file on the local file system, <em>Hadoop Distributed File System</em> (HDFS), or Amazon S3. You instantiate an <code>Hfs</code> instance for Hadoop or S3 file systems, and a <code>FileTap</code> instance for local file system. There are also more specialized versions for particular scenarios, like specifying a "template" for file or directory naming conventions.</p>

<h2>Scheme</h2>

<p>The <strong>Scheme</strong> encapsulates the file format. There are several supported natively by Cascading. The corresponding Java class names are used in the following subsections.</p>

<h3>TextLine</h3>

<p>When read, each line of text in the file is returned, with no attempt to tokenize it into fields. The position, byte offset or line number, in the file for the line is also returned. In the Hadoop model of key-value data pairs, the offset is the key and the line is the value.</p>

<p>When written, tuple fields are serialized to text and separated by tabs.</p>

<p>Available for both local file systems and Hadoop.</p>

<h3>TextDelimited</h3>

<p>Handles data where each line is a tuple with fields separated by delimiters, such as tabs and commas. Quoted strings with nested delimiters and files with column headers can be handled. Fields can be cast to primitive types.</p>

<p>Available for both local file systems and Hadoop.</p>

<h3>SequenceFile</h3>

<p>A binary, Hadoop-only data format.</p>

<h3>WritableSequenceFile</h3>

<p>A more efficient implementation of SequenceFile.</p>

<h2>Pipe</h2>

<p><strong>Pipes</strong> are units of processing through which tuples are streamed. They are composed into <strong>Assemblies</strong>. Pipes are provided to merge and join streams, split them into separate streams, group them, filter them, etc.</p>

<h2>Flow</h2>

<p>A <strong>Flow</strong> is created whenever a Tap is connected to a Pipe. Flows can also be composed.</p>

<h2>Cascade</h2>

<p>A <strong>Cascade</strong> joins flows and supports a model where a flow is only executed if the target output doesn't exist is older than the input data, analogous to build tools like <code>make</code>.</p>

<h1>The Workshop</h1>

<p>Each section introduces one or more features for data manipulation, most of which are analogous to features found in SQL, Pig (the Hadoop <em>data flow</em> tool), and other systems.</p>

<h2>Sanity Check</h2>

<p>First, the <a href="README.html">README</a> tells you to run a <code>SanityCheck0.scala</code> Scalding script as a sanity check to verify that your environment is ready to go.</p>

<p>Using <code>bash</code>:</p>

<pre><code>    cd $HOME/fun/scalding-workshop
    ./run scripts/SanityCheck0.scala
</code></pre>

<p>On Windows:</p>

<pre><code>    cd C:\fun\scalding-workshop
    scala run scripts/SanityCheck0.scala
</code></pre>

<p>From now on, I'll assume you are working in the <code>scalding-workshop</code> directory, unless otherwise noted. Also, I'll just show the <code>bash</code> versions of the subsequent <code>run</code> commands. Finally, because I'm lazy ;), I'll sometimes drop the <code>.scala</code> extension from script names when I discuss them in the text.</p>

<p>Run these commands again and verify that they run without error. The output is written to <code>output/SanityCheck0.txt</code>. What's in that file?</p>

<p>It contains the contents of <code>SanityCheck0.scala</code>, but each line is now numbered.</p>

<p>The essence of this script is the following three lines:</p>

<pre><code>val in  = TextLine("scripts/SanityCheck0.scala")
val out = TextLine("output/SanityCheck0.txt")
in.read.write(out)
</code></pre>

<p>It reads each line and writes it back out. The <code>TextLine</code> format has an implicit "schema" for each line, the line number, called the <code>'offset</code>, which it adds, and the line itself, called <code>'line</code>. This naming convention that uses Scala <em>symbols</em> is a Scalding convention. So, the reason we have the line numbers in the output file is because they were added by <code>TextLine</code>.</p>

<blockquote><p>By default, when you create a new field in a <strong>pipeline</strong>, Cascading adds the field to the existing fields. All the fields together constitute a <strong>tuple</strong>.</p></blockquote>

<h2>Projecting Fields</h2>

<p>When you write a SQL <code>SELECT</code> statement like the following, you are <em>projecting</em> out the fields/columns or calculated values that you want, and discarding the rest of the fields.</p>

<pre><code>SELECT name, age FROM employees;
</code></pre>

<p>Scalding also has a <code>project</code> method for the same purpose. Let's modify <code>SanityCheck0</code> to project out just the line we read from the file, discarding the line number. <code>Scripts/Project1.scala</code> has this change near the end of the file:</p>

<pre><code>in
  .read
  .project('line)
  .write(out)
</code></pre>

<p>This expression is a sequence of Cascading <a href="http://docs.cascading.org/cascading/2.0/javadoc/cascading/pipe/Pipe.html">Pipes</a>. However, there is no <code>write</code> method defined on the <code>Pipe</code> class. Scalding uses a feature in Scala called <em>implicit conversions</em> to wrap <code>Pipe</code> with a Scalding-specific type called <code>com.twitter.scalding.RichPipe</code>. It provides most of the methods we'll actually use, like <code>write</code>.</p>

<blockquote><p>There are also comments in this script and the ones that follow about specific Scalding and Cascading features that I won't cover in these notes.</p></blockquote>

<p>Run the script thusly:</p>

<pre><code>    ./run scripts/Project1.scala
</code></pre>

<p>Now, if you look at the output in <code>output/Project1.txt</code>, you'll see just the original lines from <code>scripts/Project1.scala</code>. That is, running a <code>diff</code> command on the input and output files should show no differences.</p>

<h2>FlatMap and GroupBy - Implementing Word Count</h2>

<p>This exercise introduces several new concepts and implements the famous <em>hello world!</em> of Hadoop programming: <em>word count</em>. In word count, a corpus of documents is read, the content is tokenized into words, and the total count for each word over the entire corpus is computed.</p>

<p>First, we'll use two new invocation command options:</p>

<ul>
<li><code>--input file</code> specifies the input file.</li>
<li><code>--output file</code> specifies the output file.</li>
</ul>


<blockquote><p>We are running in "local" mode, using the <code>--local</code> command option. In this case, we have to specify input and output files. If we were running in a Hadoop cluster, we would specify directories instead and Hadoop <em>tasks</em> (separate JVM processes) would be started to read each file, etc. This is the normal way of working with the Hadoop MapReduce API, and other tools like Hive and Pig, too.</p></blockquote>

<p>Run the script with the following command. From now on, when the commands are too long to fit easily on one line, I'll show you the command twice. First, I'll show a nicely-formatted command line that's easy to read, with line-continuation marks "\" separating the lines. Then, I'll show the command all on one line, which is easier to copy and paste:</p>

<p><strong>Nicely Formatted:</strong></p>

<pre><code>./run scripts/WordCount2.scala \ 
  --input data/shakespeare/plays.txt \ 
  --output output/shakespeare-wc.txt
</code></pre>

<p><strong>Copy and Paste Version:</strong></p>

<pre><code>./run scripts/WordCount2.scala --input data/shakespeare/plays.txt --output output/shakespeare-wc.txt
</code></pre>

<p>The output should be identical to the contents of <code>data/shakespeare-wc/simple/wc.txt</code>. Using a <code>diff</code> command, should show no differences:</p>

<pre><code>diff data/shakespeare-wc/simple/wc.txt output/shakespeare-wc.txt
</code></pre>

<p>(Or you may see a different count for the first line, the amount of whitespace seen...)</p>

<p>The script uses two new data transformation features to compute the word count, <code>flatMap</code> and <code>groupBy</code>.</p>

<h3>flatMap</h3>

<p>When you apply a <code>map</code> operation to a collection, each element is passed to a function that returns a new element, perhaps of a completely different type. For example, mapping a collection of integers to a collection of their string representations. A crucial feature of <code>map</code> is that the process is <em>one-to-one</em>. Each input element has a corresponding output element and the sizes of the input and output collections are the same.</p>

<p>The <code>flatMap</code> operation is similar, but now the output of the function called for each element is a collection of zero or more new elements. These output collections from each function call are <em>flattened</em> into a single collection. So, a crucial difference compared to <code>map</code> is that the process is <em>one-to-many</em>, where <em>many</em> could be zero!</p>

<p><code>WordCount2</code> uses <code>flatMap</code> to convert each line of input text into many words:</p>

<pre><code>.flatMap('line -&gt; 'word){ 
    line : String =&gt; line.toLowerCase.split(tokenizerRegex)
}
</code></pre>

<p>where <code>tokenizerRegex</code> is <code>"\\s+"</code>.</p>

<p>A bit of Scala syntax; there are <em>two</em> argument lists passed to <code>flatMap</code>. The first, <code>('line -&gt; 'word)</code> specifies the field(s) in the tuple to pass to the mapping function, shown on the left-hand side of the arrow-like <code>-&gt;</code>, and it names the output field(s) the function will return, the single <code>'word</code> in this case.</p>

<p>The second function argument list is <code>{ line : String =&gt; line.toLowerCase.split(tokenizerRegex)}</code>. Scala lets you substitute curly braces <code>{...}</code> for parentheses <code>(...)</code> for function argument lists, which is most useful when the content of the "block-like" structure is a single <em>function literal</em> (a.k.a. <em>anonymous function</em>).</p>

<p>The <code>line : String</code> is the argument list passed to the anonymous function, a single parameter named <code>line</code> of type <code>String</code>. On the right-hand side of the arrow-like <code>=&gt;</code> is the body of the anonymous function. In this case it converts <code>line</code> to lower case and splits it on whitespace into an array of words.</p>

<h3>groupBy</h3>

<p>Once we have a stream of individual words, we want to count the occurrences of each word. To do that, we need to group together all occurrences of the same words. The <code>groupBy</code> operation is used by <code>WordCount2</code> to do this.</p>

<pre><code>.groupBy('word){group =&gt; group.size('count)}
</code></pre>

<p>The calling syntax is similar to <code>flatMap</code>. The first argument list specifies one or more fields to group over, forming the "key". The second argument is a function literal. It takes a single argument of type <code>com.twitter.scalding.GroupBuilder</code> that gives us a hook to the constructed group of words so we can compute what we need from it. In this case, all we care about is the size of the group, which we name <code>'count</code>.</p>

<h3>Further Exploration</h3>

<p>Try these additional "mini-exercises" to explore what Scalding and Cascading are doing.</p>

<h4>Improve the Tokenization</h4>

<p>Look at the output and you'll notice that the tokenization is rather poor. How can you improve the value defined in <code>tokenizerRegex</code>? Can you pass in the regular expression as an argument to the program?</p>

<h4>Project the 'num Field</h4>

<p>Instead of projecting out <code>'line</code>, project out <code>'num</code>, the line number. (The output is boring, but now you know the name of this field!)</p>

<p>Try these additional "mini-exercises" to explore what Scalding and Cascading are doing.</p>

<h4>Remove the groupBy</h4>

<p>Comment out the <code>groupBy</code> line so that the raw results of <code>flatMap</code> are written to the output instead of the word count output. Note the fields that are written.</p>

<p>You'll see the line number, the whole line, and an individual word from the line. Note that the line number and line are repeated for each word in the line.</p>

<h4>Group Again by Count</h4>

<p>Now restore the <code>groupBy</code> line, and after it, add this line:</p>

<pre><code>.groupBy('count){ group =&gt; group.mkString('word -&gt; 'words, "\t") }
</code></pre>

<p>The output lines will be extremely long at the beginning of the file, but very short at the end. This second <code>groupBy</code> regroups the <code>'word</code> and <code>'count</code> output from the previous pipe. It groups by count so we now have all the words with one occurrence on a line, followed by all the words with two occurrences, etc. At the end of the output, which words have the most occurrences? What are those "words"?</p>

<h4>Improve the Word Tokenization</h4>

<p>You probably noticed that simply splitting on whitespace is not very good, as punctuation is not removed. There are several ways it can be improved. First, replacing the definition of <code>tokenizerRegex</code>, which is <code>"\\s+"</code>, with <code>"\\W+"</code> will treat all runs of non-alphanumeric characters as word separators. This improves the result considerably (although it's still not perfect...).</p>

<p>For a more complete tokenizer, refactor <code>line.toLowerCase.split(tokenizerRegex)</code> into a <code>tokenize</code> function. Then implement <code>tokenize</code> to remove punctuation, etc. An example implementation can be found in the <a href="https://github.com/twitter/scalding">Scalding README</a>.</p>

<h4>Eliminate Blank Lines</h4>

<p>The very first line in the output is an empty word and a count of approximately 49,000! These are blank lines in the text. The implementation removes all other whitespace, but as written, it still returns an empty word for blank lines. Adding a filter clause will remove these lines. We'll see how below, but you can search for that section now if you want to try it.</p>

<h2>Input Parsing</h2>

<p>Let's do a similar <code>groupBy</code> operation, this time to compute the average of Apple's (AAPL) closing stock price year over year (so you'll know what entry points you missed...). Also, in this exercise we'll solve a common problem; the input data is in an unsupported format.</p>

<p><strong>Nicely Formatted:</strong></p>

<pre><code>./run scripts/StockAverages3.scala \ 
  --input data/stocks/AAPL.csv \ 
  --output output/AAPL-year-avg.txt
</code></pre>

<p><strong>Copy and Paste Version:</strong></p>

<pre><code>./run scripts/StockAverages3.scala  --input data/stocks/AAPL.csv --output output/AAPL-year-avg.txt
</code></pre>

<p>You should get the following output (the input data ends in early 2010):</p>

<pre><code>1984    80      2.918625000000001       0.17609474544971507
1985    253     2.3041501976284584      0.5150177183048612
1986    253     3.7039130434782592      0.6311900614112455
1987    253     8.90608695652174        1.9436409195268336
1988    253     9.564703557312258       0.5662800839386863
1989    252     9.684563492063495       0.9768865589941155
1990    253     8.826126482213441       1.0871208010962554
1991    253     12.469169960474305      1.66952305050656
1992    254     13.130669291338577      1.7661116441071
1993    253     9.920395256916992       3.1660729659295854
1994    252     8.369880952380953       1.0934696061063884
1995    252     10.075198412698407      1.0061968512619912
1996    254     6.229881889763783       0.8162148485315347
1997    253     4.491818181818182       0.7140447712304852
1998    252     7.641666666666666       1.6581179568203712
1999    252     14.443214285714282      5.433605126282854
2000    252     22.856230158730177      8.415990854209504
2001    248     10.109758064516127      1.2389205523420814
2002    252     9.569920634920635       2.150379256336458
2003    252     9.272619047619047       1.6510305480966423
2004    252     17.763888888888886      6.577299642773537
2005    252     46.67595238095237       11.4046392452893
2006    251     70.81063745019917       9.507687243758655
2007    251     128.2739043824701       35.17547139617391
2008    253     141.9790118577075       33.66549448302255
2009    252     146.81412698412706      39.731840611338804
2010    25      204.7216        7.454055905344417
</code></pre>

<p>Note that as I write this (September 2012), AAPL is currently trading at ~$700/share! <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<h3>Musical Interlude: Comparison with Hive and Pig</h3>

<p>By the way, here's the same query written using <em>Hive</em>, where we first define an "external table" that uses the same file:</p>

<pre><code>CREATE EXTERNAL TABLE IF NOT EXISTS stocks(
  ymd             STRING,
  price_open      FLOAT,
  price_high      FLOAT,
  price_low       FLOAT,
  price_close     FLOAT,
  volume          INT,
  price_adj_close FLOAT
) LOCATION 'path/to/data/AAPL.csv';

SELECT year(s.ymd), avg(s.price_close) 
FROM stocks s 
WHERE s.symbol = 'AAPL' AND s.exchange = 'NASDAQ'
GROUP BY year(s.ymd);
</code></pre>

<p>The query is a little more compact, in part because we can handle all issues of record parsing, etc. when we set up Hive tables, etc. However, Scalding gives us more flexibility when our SQL dialect and built-in functions aren't flexible enough for our needs.</p>

<p>Here's what the corresponding <em>Pig</em> script looks like (see <code>scripts/StockAverages3.pig</code>):</p>

<pre><code>aapl = load 'data/stocks/AAPL.csv' using PigStorage(',') as (
  ymd:             chararray,
  price_open:      float,
  price_high:      float,
  price_low:       float,
  price_close:     float,
  volume:          int,
  price_adj_close: float);

by_year = group aapl by SUBSTRING(ymd, 0, 4);

year_avg = foreach by_year generate group, AVG(aapl.price_close);

-- You always specify output directories:
store year_avg into 'output/AAPL-year-avg-pig';
</code></pre>

<p>If you have <em>Pig</em> installed, you can run this script (from this directory) with the following command:</p>

<pre><code>pig -x local scripts/StockAverages3.pig
</code></pre>

<p>The <code>-x local</code> option means that Pig will treat the paths as references to the local file system, not the Hadoop Distributed File System (HDFS).</p>

<h2>Improving the Syntax</h2>

<p><code>StockAverages3.scala</code> uses an anonymous function that takes a tuple
argument, which results in slightly ugly syntax. We can't use <code>PartialFunction</code>, e.g.,</p>

<pre><code>{ case (ymd, close) =&gt; ... }
</code></pre>

<p>But we can do a match on the tuple argument instead!</p>

<p><strong>Nicely Formatted:</strong></p>

<pre><code>./run scripts/StockAverages3a.scala \ 
  --input data/stocks/AAPL.csv \ 
  --output output/AAPL-year-avg.txt
</code></pre>

<p><strong>Copy and Paste Version:</strong></p>

<pre><code>./run scripts/StockAverages3a.scala --input data/stocks/AAPL.csv --output output/AAPL-year-avg.txt
</code></pre>

<h3>Further Exploration</h3>

<p>Try these additional "mini-exercises" to learn more.</p>

<h4>Project Other Averages</h4>

<p>Try projecting averages for one or more other fields.</p>

<h4>Pig</h4>

<p>If you have Pig installed, try the Pig script. Compare the performance of the Pig vs. Scalding script, but keep in mind that because we're running in local mode, the performance comparison won't mean as much as when you run in a Hadoop cluster.</p>

<h4>Hive</h4>

<p>If you have Hive installed, try the Hive query shown above. You'll need to create a table that uses the data files first. Compare the performance of the Hive vs. Scalding script, keeping in mind the caveats mentioned for Pig.</p>

<h2>Error Handling</h2>

<p>What if some of the input records are bad. This is actually common in real-world data analytics. Let's adapt <code>StockAverages3</code> to handle the case where invalid entries for the date or closing price are encountered. That is, they don't successfuly parse the year as an integer or the closing price as a double. We'll split the stream into "good" and "bad" data, writing the bad data to a separate "errors" output for subsequent inspection, clean-up, or whatever.</p>

<p>The script is very similar to the previous one, so we'll just call it <code>StockAverages3b</code>. (The comments in the script describe the implementation differences, as usual...) Note that we need to specify a different input file, where we've introduced 5 bad records, and an <code>errors</code> argument for the errors stream, which will contain 5 errors records after the script has finished:</p>

<p><strong>Nicely Formatted:</strong></p>

<pre><code>./run scripts/StockAverages3b.scala \ 
  --input data/stocks/AAPL-with-errors.csv \ 
  --output output/AAPL-year-avg.txt \ 
  --errors output/AAPL-errors.txt
</code></pre>

<p><strong>Copy and Paste Version:</strong></p>

<pre><code>./run scripts/StockAverages3b.scala --input data/stocks/AAPL-with-errors.csv --output output/AAPL-year-avg.txt --errors output/AAPL-errors.txt
</code></pre>

<h3>Further Exploration</h3>

<p>Try these additional "mini-exercises" to learn more.</p>

<h4>What Happens if You Use the Bad Input with StocksAverages3?</h4>

<p>Run the previous command replacing <code>StockAverages3b</code> with <code>StockAverages3</code>. (Omit the <code>--errors</code> argument or leave it, in which case it will be ignored by <code>StockAverages3</code>.) Notice the exceptions that are thrown when you hit the first bad input record.</p>

<h4>Improve the Bad Record Information</h4>

<p>When you look at the content of <code>output/AAPL-errors.txt</code>, it isn't very helpful for debugging the problem because it only shows a bad year and/or closing price value, not the full record that was bad. At least having the full dates would help track down the bad records.</p>

<p>We're using <code>mapTo</code> to discard the fields we no longer need, rather than <code>map</code>, which would append the new fields to the existing fields.</p>

<p>Fortunately, all you need to do is modify the script to use <code>map</code> instead, because the subsequent <code>groupBy</code> will discard the unwanted fields anyway. (In fact, the <code>project</code> we do early on isn't really necessary, although it probably improves performance by reducing network I/O to shuffle larger records around the cluster...) We don't use <code>groupBy</code> on the error stream, so it keeps the data we want in that output.</p>

<p>Change <code>mapTo</code> to <code>map</code>, rerun the script, and look at the new content of <code>output/AAPL-errors.txt</code>. Did <code>output/AAPL-year-avg.txt</code> change?</p>

<p>A final note, if we didn't do a grouping operation of some kind, you could follow the <code>map</code> step with a <code>project</code> on the <code>good</code> pipe to keep just the final <code>year</code> and <code>close</code> fields, etc. Using <code>mapTo</code> is more efficient than separate <code>map</code> and <code>project</code> (or <code>discard</code>) steps.</p>

<h2>Joins</h2>

<p>Let's join stocks and dividend data. To join two data sources, you set up to pipe assemblies and use one of the join operations.</p>

<p><code>scripts/StocksDividendsJoin4</code> performs an <em>inner join</em> of stock and dividend records. Let's invoke for Apple data (yes, although Apple only recently announced that it would pay a dividend, Apple paid dividends back in the late 80s and early 90s.):</p>

<p><strong>Nicely Formatted:</strong></p>

<pre><code>./run scripts/StocksDividendsJoin4.scala \ 
--stocks data/stocks/AAPL.csv \ 
--dividends data/dividends/AAPL.csv \ 
--output output/AAPL-stocks-dividends-join.txt
</code></pre>

<p><strong>Copy and Paste Version:</strong></p>

<pre><code>./run scripts/StocksDividendsJoin4.scala --stocks data/stocks/AAPL.csv --dividends data/dividends/AAPL.csv --output output/AAPL-stocks-dividends-join.txt
</code></pre>

<p>Note that we need to two input sources, so we use flags <code>--stocks</code> and <code>--dividends</code> for them, instead of <code>--input</code>.</p>

<h3>Further Exploration</h3>

<p>Try these additional "mini-exercises" to learn more.</p>

<h4>Left Outer Join</h4>

<p>Change <code>joinWithSmaller</code> to <code>leftJoinWithSmaller</code> to perform a left-outer join. (Also change the output file name to something else). You have to scroll a ways into file to find dividends. See also the next mini-exercise.</p>

<h4>Filtering by Year</h4>

<p>Sometimes you want to filter records, say to limit the output. Add the following filter clause to limit the records to 1988:</p>

<pre><code>.filter('symd){ ymd: String =&gt; ymd.startsWith("1988")}
</code></pre>

<p>Try moving it to different positions in the pipe assembly and see if the execution times change. However, the data set is small enough that you might not notice a difference.</p>

<h4>Filtering Blank Lines from WordCount2</h4>

<p>Recall in the <code>WordCount2</code> exercise that we had thousands of blank lines that got counted. Add a <code>filter</code> before the <code>groupBy</code> that keeps only those words whose lengths are greater than zero.</p>

<h2>CoGroups</h2>

<p>CoGroups in Scalding are used internally to implement joins of two pipe assemblies. Clients can also use them to implement joins of three or more pipe assemblies, so-called <em>star joins</em>. You should always use the largest data stream as the first one in the join, because the Cascading implementation is optimized for this scenario.</p>

<p>However, in this exercise, we'll do a four-way self-join of the data files for the four stocks symbols I provided, AAPL, INTC, GE, and IBM.</p>

<p>For this script, the <code>--input</code> flag is used to specify the directory where the stocks files are located.</p>

<p><strong>Nicely Formatted:</strong></p>

<pre><code>./run scripts/StockCoGroup5.scala \ 
  --input data/stocks \ 
  --output output/AAPL-INTC-GE-IBM.txt
</code></pre>

<p><strong>Copy and Paste Version:</strong></p>

<pre><code>./run scripts/StockCoGroup5.scala --input data/stocks --output output/AAPL-INTC-GE-IBM.txt
</code></pre>

<p>When you look at the implementation, it is not obvious how to use the CoGroup feature. You could do pair-wise joins, which would be conceptually easier perhaps, but offer poor performance in a large MapReduce job, as each pair would require a separate MapReduce Job. The CoGroup feature tries to do as many joins at one as possible.</p>

<p>For comparison, here is the equivalent Hive join.</p>

<pre><code>SELECT a.ymd, a.symbol, a.price_close, b.symbol, b.price_close, 
              c.symbol, c.price_close, d.symbol, d.price_close 
              FROM stocks a 
          JOIN stocks b ON a.ymd = b.ymd
          JOIN stocks c ON a.ymd = c.ymd
          JOIN stocks d ON a.ymd = d.ymd
             a.symbol = 'AAPL' AND 
             b.symbol = 'INTC' AND 
             c.symbol = 'GE'   AND 
             d.symbol = 'IBM'
</code></pre>

<p>Note that because <code>a.ymd</code> appears in all <code>ON</code> clauses, Hive will perform this four-way join in a single MapReduce job.</p>

<h3>Further Exploration</h3>

<h4>Star Joins, One Pair at a Time</h4>

<p>Try implementing the same four-way join doing a sequence of pair-wise joins. Compare the complexity of the code and the performance of the join with the CoGroup implementation. The performance would be much slower in MapReduce, where each pair-wise join would require a separate MapReduce job.</p>

<h2>Splitting a Pipe</h2>

<p>This exercise shows how to split a data stream and use various features on the splits, including finding unique values.</p>

<p><strong>Nicely Formatted:</strong></p>

<pre><code>./run scripts/Twitter6.scala \ 
  --input data/twitter/tweets.tsv \ 
  --uniques output/unique-languages.txt \ 
  --count-star output/count-star.txt \ 
  --count-star-100 output/count-star-100.txt
</code></pre>

<p><strong>Copy and Paste Version:</strong></p>

<pre><code>./run scripts/Twitter6.scala --input data/twitter/tweets.tsv --uniques output/unique-languages.txt --count-star output/count-star.txt --count-star-100 output/count-star-100.txt
</code></pre>

<p>The output in <code>output/unique-languages.txt</code> is the following:</p>

<pre><code>en
es
id
ja
ko
pt
ru
</code></pre>

<p>There are seven languages in the tweet records (although they aren't necessary an accurate representation of the text of the tweet). The script filtered out an invalid value that looks vaguely like a null <code>\\N</code>! The null "language" occurs for for messages in the stream that aren't tweets, but the results of other user-invoked actions.</p>

<p>The output in <code>output/count-star.txt</code> is a single line with the value 889; there are 889 lines that have the non-null values for the language. Similarly, <code>output/count-star-100.txt</code> should contain the value of 100, reflecting the <code>limit(100)</code> step added to its dataflow.</p>

<p>Note that the implementations use <code>groupAll</code>, then count the elements in the single group, via the <code>GroupBuilder</code> object. (The <code>count</code> method requires that we specify a field. We arbitrarily picked <code>tweet_id</code>.)</p>

<p>By the way, this pattern is <em>exactly</em> how Pig implements <code>COUNT(*)</code>. For example:</p>

<pre><code>grouped = group tweets all;
count = foreach grouped generate COUNT(tweets);
</code></pre>

<p>Now you're a Pig programmer. You're welcome...</p>

<p>Here, <code>tweets</code> would be the equivalent of a Pipe and <code>grouped</code> is the name of a new Pipe created by grouping all records together into one new record. The <code>foreach ... generate</code> statement iterates through this single record and projects the <code>COUNT</code> of the group contents (named <code>tweets</code> after the original relation).</p>

<p>Note, the <code>limit(...)</code> feature appeared to have a bug that caused a <em>divide by zero</em> error in earlier versions of Scalding that only appeared when running in local mode, but not when running Hadoop jobs. (Or, it might have been a Cascading bug...)</p>

<h3>Further Exploration</h3>

<h4>Debug Setting</h4>

<p>Add the <code>debug</code> pipe to the pipe assembly. How does it change the console output? This is a very useful feature when you're learning or debugging problems.</p>

<h4>Filter for Bad Languages</h4>

<p>Add a <code>filter</code> method call that removes these "bad" records. <strong>Hint:</strong> You'll want to remove all tuples where the language value is <code>"""\N"""</code>. Without the triple quotes, you would have to write <code>"\\N"</code>.</p>

<h2>Compute NGrams</h2>

<p>Let's return to the Shakespeare data to compute <em>context ngrams</em>, a common natural language processing technique, where we provide a prefix of words and find occurrences of the prefix followed by an additional word. The ngrams are returned in order of frequency, descending.</p>

<p><strong>Nicely Formatted:</strong></p>

<pre><code>./run scripts/ContextNGrams7.scala \ 
  --input data/shakespeare/plays.txt \ 
  --output output/context-ngrams.txt \ 
  --ngram-prefix "I love" \ 
  --count 10
</code></pre>

<p><strong>Copy and Paste Version:</strong></p>

<pre><code>./run scripts/ContextNGrams7.scala --input data/shakespeare/plays.txt --output output/context-ngrams.txt --ngram-prefix "I love" --count 10
</code></pre>

<p>The output is the list containing each ngram along with a count of its occurrences. Note that the list is actually written to the console, as well as to the output location. We added a <code>debug</code> step to the dataflow that dumps the tuples to the console.</p>

<p>The data set isn't large enough to find a lot of examples for many possible ngrams.</p>

<h3>Further Exploration</h3>

<h4>Experiment with Different Prefixes</h4>

<p>Try other prefixes of different lengths. You don't have to specify a two-word prefix!</p>

<h4>Try Using Other Text Files</h4>

<p>Run the script on other large text files you have.</p>

<h4>NGram Detector</h4>

<p>Context ngrams are a special case of ngrams, where you just find the most common n-length phrases. Put another way, "regular" ngrams are like context ngrams with no prefix. Write a script to compute the most common ngrams.</p>

<h2>Joining Pipes</h2>

<p>Let's revisit the exercise to join stock and dividend records and generalize it to read in multiple sets of data, for different companies, and process them as one stream. A complication is that the data files don't contain the stock ("instrument") symbol, so we'll see another way to add data to tuples.</p>

<p><strong>Nicely Formatted:</strong></p>

<pre><code>./run scripts/StocksDividendsRevisited8.scala \ 
  --stocks-root-path data/stocks/ \ 
  --dividends-root-path data/dividends/ \ 
  --symbols AAPL,INTC,GE,IBM \ 
  --output output/stocks-dividends-join.txt
</code></pre>

<p><strong>Copy and Paste Version:</strong></p>

<pre><code>./run scripts/StocksDividendsRevisited8.scala --stocks-root-path data/stocks/ --dividends-root-path data/dividends/ --symbols AAPL,INTC,GE,IBM --output output/stocks-dividends-join.txt
</code></pre>

<h1>Matrix API</h1>

<p>The Matrix API is relatively new and facilities many important machine learning algorithms.</p>

<h2>Jaccard Similarity and Adjacency Matrices</h2>

<p><em>Adjacency matrices</em> are used to record the similarities between two things. For example, the "things" might be users who have rated movies and the <em>adjacency</em> might be how many movies they have reviewed in common. Higher adjacency numbers indicate more likely similarity of interests. Note that this simple representation says nothing about whether or not they both rated the movies in a similar way.</p>

<p>Once you have adjacency data, you need a <em>similarity measure</em> to determine how similar to things (e.g., people) really are. One is <em>Jaccard Similarity</em>:</p>

<p><img src="images/JaccardSimilarity.png" alt="" /></p>

<p>This is set notation; the size of the intersection of two sets over the size of the union. It can be generalized and is similar to the cosine of two vectors normalized by length. Note that the distance would be 1 - similarity.</p>

<p>Run the script this way on a small matrix:</p>

<p><strong>Nicely Formatted:</strong></p>

<pre><code>./run scripts/MatrixJaccardSimilarity9.scala \ 
  --input data/matrix/graph.tsv \ 
  --output output/jaccardSim.tsv
</code></pre>

<p><strong>Copy and Paste Version:</strong></p>

<pre><code>./run scripts/MatrixJaccardSimilarity9.scala --input data/matrix/graph.tsv --output output/jaccardSim.tsv
</code></pre>

<h2>Term Frequency-Inverse Document Frequency (TF*IDF)</h2>

<p>TF<em>IDF is a widely used </em>Natural Language Processing<em> tool to analyze text. It's useful for indexing documents, e.g., for web search engines. Naively, you might calculate the </em>frequency* of words in a corpus of documents and assume that if a word appears more frequently in one document, then that document is probably a "definitive" place for that word, such as the way you search for web pages on a particular topic. Similarly, the most frequent words indicate the primary topics for a document.</p>

<p>There's a problem, though. Very common words, e.g., articles like "the", "a", etc. will appear very frequently, undermining results. So we want to remove them so how. Fortunately, they tend to appear frequently in <em>every</em> document, so you can reduce the ranking of a particular word if you <em>divide</em> its frequency in a given document by its frequency in <em>all</em> documents. That's the essence of TF*IDF.</p>

<p>For more information, see the <a href="http://en.wikipedia.org/wiki/Tf*idf">Wikipedia</a> page.</p>

<p>Run the script this way on a small matrix:</p>

<p><strong>Nicely Formatted:</strong></p>

<pre><code>./run scripts/TfIdf10.scala \ 
  --input data/matrix/docBOW.tsv \ 
  --output output/featSelectedMatrix.tsv \ 
  --nWords 300
</code></pre>

<p><strong>Copy and Paste Version:</strong></p>

<pre><code>./run scripts/TfIdf10.scala --input data/matrix/docBOW.tsv --output output/featSelectedMatrix.tsv --nWords 300
</code></pre>

<h1>Type-Safe API</h1>

<p>So far, we have been using the original <em>Fields-Based API</em>, which emphasizes naming fields and uses a relatively dynamic approach to typing. This is consistent with Cascading's model.</p>

<p>There is newer, more experimental <em>Type-Safe API</em> that attempts to more fully exploit the type safety provided by Scala. It's not as well documented, but the place to start is the <a href="https://github.com/twitter/scalding/wiki/Type-safe-api-reference">Type-Safe API Reference page</a>.</p>

<p>Here is <code>Twitter6</code> ported to this API. The comments in the script explain what's different. The output is the same for <code>output/unique-languages.txt</code> and <code>output/count-star.txt</code>. However, instead of just counting 100 lines, this time we write the 100 lines (and we also changed the command-line option):</p>

<p><strong>Nicely Formatted:</strong></p>

<pre><code>./run scripts/Twitter6Typed.scala \ 
  --input data/twitter/tweets.tsv \ 
  --uniques output/unique-languages.txt \ 
  --count-star output/count-star.txt \ 
  --first-100 output/first-100.txt
</code></pre>

<p><strong>Copy and Paste Version:</strong></p>

<pre><code>./run scripts/Twitter6Typed.scala --input data/twitter/tweets.tsv --uniques output/unique-languages.txt --count-star output/count-star.txt --first-100 output/first-100.txt
</code></pre>

<h1>Using Scalding with Hadoop</h1>

<p>A great feature of Cascading, which Scalding exploits, is the ability to test locally before running on Hadoop. This improves the iterative development and feedback cycle.</p>

<p>I've provided a bash shell script, <code>run11.sh</code> to run the job on Hadoop, but first, let's discuss Scalding's own approach.</p>

<p>Once you're ready to try it in Hadoop, the "official" Scalding way is to use the <code>scripts/scald.rb</code> script in the Scalding distribution. For example, assuming that you cloned the Scalding repo into <code>$SCALDING_HOME</code>, here is a command to run <code>src/main/scala/HadoopTwitter11.scala</code>, which is actually <em>identical</em> to <code>Twitter6</code> that we ran previously, except for comments. (I put it in <code>src/main/scala</code> so the sbt build adds it to the assembly.):</p>

<p><strong>Nicely Formatted:</strong></p>

<pre><code>../scalding/scripts/scald.rb -local --host localhost \
  src/main/scala/HadoopTwitter11.scala \
  --input           data/twitter/tweets.tsv \
  --uniques         output/unique-languages \
  --count-star      output/count-star \
  --count-star-100  output/count-star-100
</code></pre>

<p><strong>Copy and Paste Version:</strong></p>

<pre><code>../scalding/scripts/scald.rb -local --host localhost src/main/scala/HadoopTwitter11.scala --input data/twitter/tweets.tsv --uniques output/unique-languages --count-star output/count-star --count-star-100 output/count-star-100
</code></pre>

<p>Use the server address with your <em>JobTracker</em> for the <code>--host</code> flag on a real Hadoop cluster. Also, replace <code>--local</code> with <code>--hdfs</code> so that HDFS is actually used. For this to work, you'll need to copy the <code>data/twitter</code> directory to your HDFS home directory (i.e., <code>/user/$USER</code>) and also create an <code>output</code> directory there.</p>

<p>Finally, when using HDFS, the values specified for output using the <code>--uniques</code>, <code>count-star</code>, and <code>count-star-limit</code> flags will be used as <em>directories</em>, not <em>files</em>, which is why we omitted the <code>.txt</code> suffixes used before. This follows conventional Hadoop practice, where the parallel processes might result in multiple, concurrently-written output files.</p>

<p>To simplify matters, such as removing the need for you to install the Scalding distribution, I've provided a bash script, <code>run11.sh</code>, to run this exercise. You'll need access to a computer with Hadoop and bash installed. You can install Hadoop on a Mac using HomeBrew, on Linux using the appropriate package installer, and Microsoft has recently released a port of Hadoop for Windows. However, the easiest way to play with Hadoop is to install a VMWare or VirtualBox runner and download a completely configured image file from Cloudera, MapR, or Hortonworks.</p>

<p>I'll just demonstrate using <code>run11.sh</code> in the Workshop. Using all the default settings, just run:</p>

<pre><code>run11.sh
</code></pre>

<p>This runs in local mode using the local file system, the MapReduce APIs, but not the full set of Hadoop services and HDFS. For help on the options to change the defaults:</p>

<pre><code>run11.sh --help
</code></pre>

<p>The output will be identical to what you saw for the previous Twitter exercise.</p>

<h1>Summingbird</h1>

<p>In September, Twitter <a href="https://blog.twitter.com/2013/streaming-mapreduce-with-summingbird">unveiled</a> a new Scala API called <a href="https://github.com/twitter/summingbird">Summingbird</a>. There is also a <a href="https://github.com/sritchie/summingbird-workshop">tutorial from LambdaJam 2013</a> by one of the project creators.</p>

<p>Summingbird is designed to support a variety of backends, so that logic can be written once and executed on different systems. The initial release supports Hadoop through Scalding, <a href="http://storm-project.net/">Storm</a>, an event processing system that Twitter and many other organizations use to complement Hadoop's batch-mode capabilities. There is also an in-memory mode that uses <a href="http://memcached.org/">memcached</a>, designed for testing, but potentially also for working with smaller data sets where the scalability of Hadoop isn't needed.</p>

<p>Twitter is encouraging others to contribute backends for additional systems.</p>

<p>Because additional libraries are required for running Summingbird apps, we'll just look at our <em>Word Count</em> example ported to Summingbird. See <code>scripts/SummingbirdWordCount12.scala</code>.</p>

<h1>Conclusions</h1>

<h2>Comparisons with Other Tools</h2>

<p>It's interesting to contrast Scalding with other tools.</p>

<h3>Cascading</h3>

<p>Because Scala is a <em>functional programming</em> language with excellent support for DSL (domain-specific language) creation, using Scalding is much more concise than the Java-based Cascading itself, because Scalding programs are more concise and intuitive, fully exploiting FP idioms for data manipulation. For more on this comparison, see <a href="http://polyglotprogramming.com/papers/ScaldingForHadoop.pdf">this talk</a> that Dean Wampler gave recently at the Chicago Hadoop Users Group and Big Data Techcon Boston, 2013.</p>

<h3>Cascalog</h3>

<p>This Clojure dialect written by Nathan Marz also benefits from the functional nature and concision of Clojure. Nathan has also built in the logic-based query model of Datalog.</p>

<h3>Pig</h3>

<p>Pig has very similar capabilities, with notable advantages and disadvantages.</p>

<h4>Advantages</h4>

<ul>
<li><em>A custom language</em> - A purpose-built language for a particular domain can optimize expressiveness for common scenarios.</li>
<li><em>Type Safety</em> - Although Scala is strongly-typed, Cascading isn't, at least in the sense that you don't normally define the types of fields, except where necessary (e.g., to call math routines with numbers). Pig (like Hive) encourages specifying the type of every field.</li>
<li><em>Lazy evaluation</em> - you define the work flow, then Pig compiles, optimizes, and runs it when output is required. Scalding, following Scala, uses eager evaluation; each expression is executed as soon as it's parsed.</li>
<li><em>Describe</em> - The describe feature is very helpful when learning how each Pig statement defines a new schema. There is an API call, <code>fields</code> on Pipes to get the field names, but it's less convenient to use, especially in interactive scenarios.</li>
</ul>


<h4>Disadvantages</h4>

<ul>
<li><em>Not Turing complete</em> - You have to write extensions in other languages. By using Scala, Scalding lets you write everything in one language.</li>
<li><em>Slower</em> - At least for local jobs, Scalding (and Cascading) avoid Hadoop APIs completely and therefore run noticeably faster.</li>
</ul>


<h3>Hive</h3>

<p>Hive is ideal when your problem fits the SQL model for queries. It's less useful for complex transformations. Also, like Pig, extensions must be written in another language.</p>

<p>When I work in Hadoop, my two tools for almost all work are Hive and Scalding. To learn more about Hive, see <a href="http://shop.oreilly.com/product/0636920023555.do">Programming Hive</a>.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>But when I&rsquo;ve periodically refined these notes since then, the price fluctuated between $400 and $550 per share. <a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</body>
</html>